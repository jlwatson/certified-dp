#![allow(warnings)]

mod pedersen;

use rand::rngs::OsRng;
use rand::{Rng, CryptoRng};
use rand::seq::IteratorRandom;
use std::collections::HashMap;
use std::io::{self, Write};
use std::ops::Neg;
use pedersen::{setup, commit, commit_with_r, verify, PublicParams};
use curve25519_dalek::{ristretto::RistrettoPoint, scalar::Scalar};

// database
const D: usize = 16;
const TEST_DATA: [u16; 4] = [
    0xdead,
    0xbeef,
    0xdaad,
    0xeebe,
];
const LOG_DATA_LEN: u32 = TEST_DATA.len().ilog2();

// monomial limit
const K: usize = 2;
const NUM_COEFFICIENTS: usize = 16;

// DP constant
// Generated by setting epsilon to 1 and delta to 1/n^(log n)
const N: usize = 8 * ((LOG_DATA_LEN * LOG_DATA_LEN) + 1) as usize;

//
// -- COMMITMENT PHASE --
//

fn calculate_monomial_sum(indices: u16, data: &[u16]) -> Scalar {

    let mut sum = Scalar::from(0 as u16);
    for i in 0..data.len() {
        let monomial: u64 = if (data[i] & indices).count_zeros() > 0 { 0 } else { 1 };
        sum += Scalar::from(monomial);
    }

    sum
}

fn generate_monomial_sums_helper(indices: u16, current_idx: u16, data: &[u16], monomial_map: &mut HashMap<u16, Scalar>) {

    if current_idx == D as u16|| indices.count_ones() == K as u32 {
        let sum = calculate_monomial_sum(indices, data);
        monomial_map.insert(indices, sum);
        return;
    }

    // set bit at current index to a 0 or 1 and recurse
    generate_monomial_sums_helper(indices, current_idx + 1, data, monomial_map);
    generate_monomial_sums_helper(indices | (1 << current_idx), current_idx + 1, data, monomial_map);
}

fn generate_monomial_sums(data: &[u16]) -> HashMap<u16, Scalar> {
    
    let mut map = HashMap::new();
    let indices: u16 = 0;

    generate_monomial_sums_helper(indices, 0, data, &mut map);

    map
}

// Map from id to (value, commitment, proof)
fn commitment_phase<T: Rng + CryptoRng>(rng: &mut T, pedersen_pp: &PublicParams) -> HashMap<u16, (Scalar, RistrettoPoint, Scalar)> {
    let monomial_map = generate_monomial_sums(&TEST_DATA);

    let mut monomial_commitments = HashMap::new();
    for (monomial_id, monomial_sum) in monomial_map {
        //println!("\t   {}", monomial_id);
        let (comm, proof) = commit(rng, &monomial_sum, pedersen_pp);
        monomial_commitments.insert(monomial_id, (monomial_sum, comm, proof));
    }

    monomial_commitments
}

//
// -- RANDOMNESS PHASE --
//

fn rnd_gen_phase<T: Rng + CryptoRng>(rng: &mut T, pedersen_pp: &PublicParams, C1: &RistrettoPoint, C_PROOF: &Scalar) -> Option<(Scalar, RistrettoPoint, Scalar)> {

    // CF 1: DE flips random bit and commits to i
    let dealer_b = rng.gen_range(0..2);
    let (dealer_b_comm, dealer_b_proof ) =
        commit(rng, &Scalar::from(dealer_b), &pedersen_pp); 

    // SP 1: DE commits to the same bit with fresh randomness. DE randomly selects an e.
    //       DE commits to the opposite bit and scales the original commitment 
    let (dealer_sigma_b_comm, dealer_sigma_b_proof) = 
        commit(rng, &Scalar::from(dealer_b), &pedersen_pp);

    let dealer_e = Scalar::random(rng);
    let (dealer_sigma_not_b_comm, dealer_sigma_not_b_proof) = 
        commit(rng, &(Scalar::from(1 - dealer_b) * (dealer_e + Scalar::from(1 as u32))), &pedersen_pp);

    //let dealer_sigma_fake_comm = add_comm(&dealer_sigma_not_b_comm, &scale_comm(&dealer_b_comm, &dealer_e.negate()));
    let dealer_sigma_fake_comm = dealer_sigma_not_b_comm + (dealer_e.neg() * dealer_b_comm);

    let c0 = if dealer_b == 0 { dealer_sigma_b_comm } else { dealer_sigma_fake_comm };
    let c1 = if dealer_b == 1 { dealer_sigma_b_comm } else { dealer_sigma_fake_comm };

    // CF 2: PL flips a bit and sends it
    let player_b = rng.gen_range(0..2);

    // SP 2: PL sends a random e value
    let player_e = Scalar::random(rng);

    // CF 3
    let final_commitment: RistrettoPoint;
    let final_proof: Scalar;
    let final_b: u64;

    if player_b == 0 {
        final_commitment = dealer_b_comm;
        final_proof = dealer_b_proof;
        final_b = dealer_b;
    } else { // player_b == 1
        final_commitment = C1 + dealer_b_comm.neg();
        final_proof = C_PROOF + dealer_b_proof.neg();

        final_b = 1 - dealer_b;
    }

    // SP 3
    let dealer_new_e = player_e - dealer_e;

    //let z = add_proof(&dealer_sigma_b_proof, &scale_proof(&dealer_b_proof, &dealer_new_e));
    let z = dealer_sigma_b_proof + (dealer_new_e * dealer_b_proof);

    let z0 = if dealer_b == 0 { z } else { dealer_sigma_not_b_proof };
    let z1 = if dealer_b == 1 { z } else { dealer_sigma_not_b_proof };

    let e0 = if dealer_b == 0 { dealer_new_e } else { dealer_e };
    let e1 = if dealer_b == 1 { dealer_new_e } else { dealer_e };

    // CF 4
    if player_b == 0 {
        if final_commitment != dealer_b_comm {
            println!("ERROR: player_b = 0, final_commitment != dealer_b_comm");
            return None;
        }
    } else {
        if final_commitment != C1 + dealer_b_comm.neg() {
            println!("ERROR: player_b = 1, final_commitment != C1 + dealer_b_comm.neg()");
            return None;
        }
    }

    // SP 4
    if player_e != e0 + e1 {
        println!("ERROR: player_e != e0 + e1");
        return None;
    }

    let comm_0 = commit_with_r(&Scalar::from(0 as u32), &z0, &pedersen_pp);
    if comm_0 != c0 + (e0 * dealer_b_comm) {
        println!("ERROR: comm_0 != c0 + (e0 * dealer_b_comm)");
        return None;
    }

    let comm_1 = commit_with_r(&(Scalar::from(1 as u32) + e1), &z1, &pedersen_pp);
    if comm_1 != c1 + (e1 * dealer_b_comm){
        println!("ERROR: comm_1 != c1 + (e1 * dealer_b_comm)");
        return None;
    }

    return Some((Scalar::from(final_b), final_commitment, final_proof));
}

fn rnd_add_bits<T: Rng + CryptoRng>(rng: &mut T, pp: &PublicParams, n: usize, C0: &RistrettoPoint, C1: &RistrettoPoint, C_PROOF: &Scalar) -> (Scalar, RistrettoPoint, Scalar) {

    let mut bit_sum = Scalar::from(0 as u32);
    let mut bit_comm: RistrettoPoint = *C0;
    let mut bit_proof: Scalar = *C_PROOF;

    for _ in 0..n {
        let (bit, comm, proof) = rnd_gen_phase(rng, &pp, C1, C_PROOF).unwrap();
        bit_sum += bit;
        bit_comm += comm;
        bit_proof += proof; 
    }
    
    let adjustment_factor = Scalar::from((N/2) as u32);
    let adjustment_comm = commit_with_r(&adjustment_factor, &C_PROOF, &pp);
    (bit_sum - adjustment_factor, bit_comm - adjustment_comm, bit_proof - C_PROOF)
}

//
// -- QUERYING PHASE --
//

fn query_phase(coefficients: &HashMap<u16, Scalar>, monomial_comms: &HashMap<u16, (Scalar, RistrettoPoint, Scalar)>,
               bit_sum: &Scalar, bit_comm: &RistrettoPoint, bit_proof: &Scalar) -> Option<(Scalar, RistrettoPoint, Scalar)> {

    let mut query_answer = *bit_sum;
    let mut query_commitment = *bit_comm;
    let mut query_proof = *bit_proof;

    for monomial_id in coefficients.keys() {
        if !monomial_comms.contains_key(monomial_id) {
            return None;
        }

        let (monomial_sum, monomial_comm, monomial_proof) = monomial_comms.get(monomial_id).unwrap();
        let monomial_coefficient = coefficients.get(monomial_id).unwrap();

        query_answer += monomial_coefficient * monomial_sum;
        query_commitment += monomial_coefficient * monomial_comm;
        query_proof += monomial_coefficient * monomial_proof;        
    }

    return Some((query_answer, query_commitment, query_proof));
}

fn main() {

    println!("\n-- Running proof of concept --\n");

    let mut rng: OsRng = OsRng::default();
    let pedersen_pp = setup(&mut rng);

    let C_PROOF = Scalar::from(0 as u32);
    let C0 = commit_with_r(&Scalar::from(0 as u32), &C_PROOF, &pedersen_pp);
    let C1 = commit_with_r(&Scalar::from(1 as u32), &C_PROOF, &pedersen_pp);

    print!("Commitment phase...");
    io::stdout().flush().unwrap();
    let monomial_comms = commitment_phase(&mut rng, &pedersen_pp);
    println!("complete");

    print!("Randomness phase...");
    io::stdout().flush().unwrap();
    let (bit_sum, bit_comm, bit_proof) = rnd_add_bits(&mut rng, &pedersen_pp, N, &C0, &C1, &C_PROOF);
    println!("complete");

    print!("Coefficient generation...");
    io::stdout().flush().unwrap();
    let mut coefficients: HashMap<u16, Scalar> = HashMap::new();
    for _ in 0..NUM_COEFFICIENTS {
        let mut random_id = monomial_comms.keys().choose(&mut rng).unwrap();
        while coefficients.contains_key(random_id) {
            random_id = monomial_comms.keys().choose(&mut rng).unwrap();
        }
        let coeff = Scalar::random(&mut rng);
        coefficients.insert(*random_id, coeff);
    }
    println!("complete");

    print!("Query phase...");
    io::stdout().flush().unwrap();
    let (query_answer, query_commitment, query_proof) = query_phase(&coefficients, &monomial_comms, &bit_sum, &bit_comm, &bit_proof).unwrap();
    println!("complete");

    if verify(&query_commitment, &query_proof, &query_answer, &pedersen_pp) {
        println!("\nQuery verified!\n");
    } else {
        println!("\nQuery invalid :(\n");
    }
}
